## SpringSecurity

> 本章在入门篇的基础上增加图片验证码登录和短信验证码登录

### 1 图片验证码登录

#### 1.1 登录页面增加图片验证码域
页面加载时<img src="/code/image"/>会请求接口，接口返回一个验证码图片
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>登录</title>
</head>
<body>
<div>
    <form action="/auth/form" method="post">
        <div>
            <label>用户名</label><input type="text" name="loginusername"/>
        </div>
        <div>
            <label>密码</label><input type="password" name="loginpassword"/>
        </div>
        <!--图片验证码-->
        <div>
            <label for="imageCode">图形验证码</label>
            <input type="input" id="imageCode" name="imageCode" required>
            <img src="/code/image"/>
        </div>
        <div>
            <input type="submit">
        </div>
    </form>
</div>

</body>
</html>
```
#### 1.2 声明一个封装验证码信息的实体类

> 声明一个封装验证码信息的基类`study.wyy.security.validatecode.ValidateCode`
```java
package study.wyy.security.validatecode;

import lombok.Data;

import java.time.LocalDateTime;

/**
 * @author wyaoyao
 * @data 2019-11-04 08:10
 * 封装验证码信息的基类
 */
@Data
public class ValidateCode {
    /**
     * 验证码长度
     */
    int length;
    /**
     * 过期时间
     */
    private LocalDateTime expireTime;
    /**
     * 验证码内容
     */
    private String code;

}
```

> 声明一个图片验证码的实体类，继承验证码信息的基类`study.wyy.security.validatecode.ImageCode`
```java
package study.wyy.security.validatecode;

import lombok.Data;

import java.awt.image.BufferedImage;
import java.time.LocalDateTime;

@Data
public class ImageCode extends ValidateCode {
    /**
     * 图片宽度
     */
    private int width;

    private int height;


    private BufferedImage image;

    public ImageCode(String code, BufferedImage image, int expireTime) {
        this.setCode(code);
        this.image = image;
        this.setExpireTime(LocalDateTime.now().plusSeconds(expireTime)); 
    }

   
}
```

#### 1.3 生成验证码
> 声明一个验证码生成器器接口`study.wyy.security.validatecode.ValidateCodeGenerator`
```java
package study.wyy.security.validatecode;

/**
 * @author wyaoyao
 * @data 2019-11-04 08:36
 * 验证码生成器接口
 */
public interface ValidateCodeGenerator {

    ValidateCode createCode();
}

```
> 声明一个图片验证码生成器`study.wyy.security.validatecode.ImageValidateCodeGenerator`，实现接口

```java
package study.wyy.security.validatecode;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Random;
public class ImageValidateCodeGenerator implements ValidateCodeGenerator{


    @Override
    public ValidateCode createCode() {
        int width = 67;
        int height = 23;
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);

        Graphics g = image.getGraphics();

        Random random = new Random();

        g.setColor(getRandColor(200, 250));
        g.fillRect(0, 0, width, height);
        g.setFont(new Font("Times New Roman", Font.ITALIC, 20));
        g.setColor(getRandColor(160, 200));
        for (int i = 0; i < 155; i++) {
            int x = random.nextInt(width);
            int y = random.nextInt(height);
            int xl = random.nextInt(12);
            int yl = random.nextInt(12);
            g.drawLine(x, y, x + xl, y + yl);
        }

        String code = "";
        for (int i = 0; i < 4; i++) {
            String rand = String.valueOf(random.nextInt(10));
            code += rand;
            g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110)));
            g.drawString(rand, 13 * i + 6, 16);
        }

        g.dispose();

        return new ImageCode(code, image, 60);

    }

    /**
     * 生成随机背景条纹
     *
     * @param fc
     * @param bc
     * @return
     */
    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
}
```
并将生成器注入到Spring容器中
```java
@Bean
@ConditionalOnMissingBean(ImageValidateCodeGenerator.class)
public ValidateCodeGenerator imageValidateCodeGenerator(){
    return new ImageValidateCodeGenerator();
}
```
#### 1.4 声明Controller获取图片验证码
```java
package study.wyy.security.web.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import study.wyy.security.validatecode.ImageCode;
import study.wyy.security.validatecode.ValidateCodeGenerator;

import javax.imageio.ImageIO;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@RestController
@Slf4j
public class ValidateCodeController {

    @Autowired
    private ValidateCodeGenerator imageValidateCodeGenerator;

    private String IMAGE_CODE_KEY = "SESSION_KEY_IMAGE_CODE";

    @GetMapping("/code/image")
    public void imageCode(HttpServletRequest request,HttpServletResponse response) throws IOException {
        ImageCode code = (ImageCode) imageValidateCodeGenerator.createCode();
        log.info("图片验证码为：{}",code.getCode());
        // 将验证码存到session中，后续验证的时候从session中获取
        request.getSession().setAttribute(IMAGE_CODE_KEY,code);
        ImageIO.write(code.getImage(), "JPEG", response.getOutputStream());
    }
}
```
在配置该请求不需要被拦截`study.wyy.security.config.SecurityConfig`

> 至此生成验证码逻辑已经实现，可访问登录页测试

#### 1.5 优化代码，将一些信息改为用户可配置的
验证码的长度，图片的宽度，以及后面验证验证码的url等

> 声明一个全局的Properties配置类`SecurityProperties`
```java
package study.wyy.security.properties;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@ConfigurationProperties("wyy.security")
@Data
@Component
public class SecurityProperties {

    private ImageCodeProperties imageCode = new ImageCodeProperties();
}
```

> 声明一个图片验证码的Properties配置类 `study.wyy.security.properties.ImageCodeProperties`

```java
package study.wyy.security.properties;

import lombok.Data;

@Data
public class ImageCodeProperties {

    private int width = 67;
    private int height = 23;
    private int length = 4;
    private String url = "/code/image";

}
```

> 修改代码里写死的相关常量，改为获取配置文件的内容
```java
package study.wyy.security.validatecode;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import study.wyy.security.properties.SecurityProperties;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Random;

@Slf4j
public class ImageValidateCodeGenerator implements ValidateCodeGenerator{

    @Autowired
    private SecurityProperties securityProperties;

    @Override
    public ValidateCode createCode() {
        int width = securityProperties.getImageCode().getWidth();
        int height = securityProperties.getImageCode().getHeight();
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);

        Graphics g = image.getGraphics();

        Random random = new Random();

        g.setColor(getRandColor(200, 250));
        g.fillRect(0, 0, width, height);
        g.setFont(new Font("Times New Roman", Font.ITALIC, 20));
        g.setColor(getRandColor(160, 200));
        for (int i = 0; i < 155; i++) {
            int x = random.nextInt(width);
            int y = random.nextInt(height);
            int xl = random.nextInt(12);
            int yl = random.nextInt(12);
            g.drawLine(x, y, x + xl, y + yl);
        }

        String code = "";
        log.info("图片验证码长度：{}",securityProperties.getImageCode().getLength());
        for (int i = 0; i < securityProperties.getImageCode().getLength(); i++) {
            String rand = String.valueOf(random.nextInt(10));
            code += rand;
            g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110)));
            g.drawString(rand, 13 * i + 6, 16);
        }

        g.dispose();

        return new ImageCode(code, image, 60);

    }

    /**
     * 生成随机背景条纹
     *
     * @param fc
     * @param bc
     * @return
     */
    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
}

```

> yaml配置样例
```yaml
wyy:
  security:
    image-code:
      length: 5
```

#### 1.6 验证图片验证码
> 声明一个验证码异常`study.wyy.security.exception.ValidateCodeException`

继承`org.springframework.security.core.AuthenticationException`,是Spring
Security提供的在认证过程中的出现异常的基类
> 声明一个图片验证码过滤器

该过滤器只拦截登录页面，主要用于校验验证码是否正确，如果校验失败就使用认证失败处理器处理, 
这里的认证失败处理就是将错误信息返回给前端(这里只是简单的做法)

```java
package study.wyy.security.web.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.ServletRequestBindingException;
import org.springframework.web.bind.ServletRequestUtils;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.context.request.ServletWebRequest;
import org.springframework.web.filter.OncePerRequestFilter;
import study.wyy.security.exception.ValidateCodeException;
import study.wyy.security.handler.MyFailHandler;
import study.wyy.security.validatecode.ImageCode;
import study.wyy.security.web.controller.ValidateCodeController;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

/**
 * OncePerRequestFilter 是Spring提供的一个过滤器工具类，保证一次请求只会调用一次
 */
@Slf4j
@Component
public class ImageValidateCodeFilter extends OncePerRequestFilter {
    // 注入失败处理器，处理验证失败

    @Autowired
    MyFailHandler myFailHandler;
    @Override
    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {
        log.info("请求路径URI：{}", httpServletRequest.getRequestURI());
        log.info("请求路径URL：{}", httpServletRequest.getRequestURL());
        // 该过滤器只拦截登录页面，主要用于校验验证码是否正确，
        if("/auth/form".equals(httpServletRequest.getRequestURI()) && RequestMethod.POST.toString().equals(httpServletRequest.getMethod())){
            try {
                validate(new ServletWebRequest(httpServletRequest));
            }catch (ValidateCodeException e){
                log.info(e.getMessage());
                myFailHandler.onAuthenticationFailure(httpServletRequest,httpServletResponse,e);
            }

        }
        filterChain.doFilter(httpServletRequest, httpServletResponse);

    }

    private void validate(ServletWebRequest servletWebRequest) throws ServletRequestBindingException {
        HttpSession session = servletWebRequest.getRequest().getSession();
        ImageCode codeInSession = (ImageCode) session.getAttribute(ValidateCodeController.IMAGE_CODE_KEY);
        // 获取请求中提交的图片验证码
        String codeInRequest = ServletRequestUtils.getStringParameter(servletWebRequest.getRequest(), "imageCode");

        if (StringUtils.isEmpty(codeInRequest)) {
            throw new ValidateCodeException("验证码不能为空");
        }

        if (codeInSession == null) {
            throw new ValidateCodeException("验证码不存在");
        }

        if (codeInSession.isExpried()) {
            session.removeAttribute(ValidateCodeController.IMAGE_CODE_KEY);
            throw new ValidateCodeException("验证码已过期");
        }

        if (!codeInRequest.equals(codeInSession.getCode())) {
            throw new ValidateCodeException("验证码不匹配");
        }
        session.removeAttribute(ValidateCodeController.IMAGE_CODE_KEY);
    }
}


```
#### 1.7 在SpringSecurity过滤器链上加入该过滤器
```java
package study.wyy.security.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.authentication.AuthenticationFailureHandler;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import study.wyy.security.web.filter.ImageValidateCodeFilter;


/**
 * @author wyaoyao
 * @data 2019-10-30 10:41
 */
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    AuthenticationSuccessHandler mySuccessHandler;
    @Autowired
    AuthenticationFailureHandler myFailHandler;
    @Autowired
    ImageValidateCodeFilter imageValidateCodeFilter;
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                 // 配置注册接口和swagger接口不需要身份验证
                .antMatchers("/register").permitAll()
                .antMatchers("/css/**", "/index", "/test/**", "/swagger**").permitAll()
                 // 配置登录页面不被拦截
                .antMatchers("/login.html").permitAll()
                .antMatchers("/auth/login").permitAll()
                // 配置图片验证码不需要被拦截
                .antMatchers("/code/image").permitAll()
                .anyRequest()
                .authenticated()
                .and()
            //在SpringSecurity过滤器链上加入图片验证码过滤器，放在UsernamePasswordAuthenticationFilter前面
            .addFilterBefore(imageValidateCodeFilter, UsernamePasswordAuthenticationFilter.class)
            // form表单登录
            .formLogin()
                // 指定登录页面
                .loginPage("/login.html")
                // 处理登录请求的url
                .loginProcessingUrl("/auth/form")
                // 修改登录请求的参数key
                .usernameParameter("loginusername")
                .passwordParameter("loginpassword")
                // 配置认证成功处理器
                .successHandler(mySuccessHandler)
                // 配置认证失败处理器
                .failureHandler(myFailHandler);
        
        http.csrf().disable();
    }
}
```
